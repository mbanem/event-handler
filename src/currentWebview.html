<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <style>
    .main-grid {
      display: grid;
      grid-template-columns: 33rem 20rem;
    }

    .grid-wrapper {
      display: grid;
      grid-template-columns: 20rem 12rem;
      column-gap: 0.5rem;
      row-gap: 1rem;
    }


    .span-two,
    pre {
      grid-column: 1 / span 2;
      text-align: justify;
      font-size: 12px;
      color: skyblue;
    }


    #createBtnId {
      width: 12rem;
      padding: 4px 0;
      margin: 2rem 0 0 0;
      padding: 5px 0;
      opacity: 0.8;
    }

    #createBtnId:hover {
      opacity: 1;
    }

    input[type='text'] {
      width: 18rem;
      height: 20px;
      padding: 6px 0 8px 1rem;
      outline: none;
      font-size: 16px;
      border: 1px solid gray;
      border-radius: 4px;
      outline: 1px solid transparent;
      margin-top: 8px;
      margin-bottom: 10px;
    }

    input[type='text']:focus {
      outline: 1px solid gray;
    }

    .left-column {
      grid-column: 1;
    }

    .left-column label,
    .left-column label:focus {
      display: block;
      width: 12rem;
      cursor: pointer;

    }

    .fields-list {
      position: relative;
      cursor: pointer;
    }

    .middle-column {
      position: relative;
      grid-column: 2;
      border: 1px solid gray;
      border-radius: 5px;
      margin-top: 1.45rem;
    }

    .middle-column .candidate-fields-caption {
      position: absolute;
      top: -1.5rem;
      left: 0.5rem;
      color: skyblue;
    }

    .right-column {
      position: relative;
      border: 1px solid gray;
      border-radius: 6px;
      padding: 6px 3px 8px 10px;
      margin-top: 1.5rem;

    }

    #schemaContainerId {
      height: 30rem;
      overflow-y: auto;
    }

    .right-column .prisma-model-caption {
      position: absolute;
      top: -1.5rem;
      left: 0.5rem;
      display: inline-block;
      color: skyblue;
      cursor:pointer;
    }
    .collapse-all {
      color:lightgreen;
      font-size:12px;
      border: 1px solid gray;
      border-radius:4px;
      padding: 2px 0 2px 1rem;
    }
    .embellishments {
      position: relative;
      grid-column: span 2;
      display: grid;
      grid-template-columns: 1rem 20rem;

      column-gap: 0.5rem;
      row-gap: 0.1rem;
      align-items: center;
      padding: 8px 1rem;
      border: 1px solid gray;
      border-radius: 6px;
      margin-top: 3rem;
      user-select: none;
    }

    .checkbox-item {
      display: contents;
    }

    .checkbox-item input[type='checkbox'] {
      grid-column: 1;
      justify-self: start;
      align-self: center;
      margin: 0;
    }

    .checkbox-item label {
      grid-column: 2;
      justify-self: start;
      align-self: center;
      cursor: pointer;
      line-height: 1;
      width: 25rem !important;
    }

    .checkbox-item label:hover {
      background-color: cornsilk;
      cursor: pointer;
      width: 25rem !important;
    }

    /* for CSS class names inserted as a markup string into innerHTML
      class the names should be defined :global as they are in a new scope
      but WebView CSP Restrictions: VS Code WebViews have strict CSP
      and pseudo classes do not work, though they work in Svelte
    */
    .list-el {
      background-color: skyblue;
      width: 100%;
      height: 20px;
      font-size: 18px;
      line-height: 18px;
      text-align: center;
      margin: 6px 0 0 0;
    }

    .list-el:hover {
      cursor: pointer;
    }

    .field-text {
      display: block;
      height: 20px;
      text-align: center;
    }

    .remove-hint {
      position: absolute;
      left: 1.5rem !important;
      z-index: 10;
      font-size: 12px;
      color: red;
      padding: 0 0.5rem 1px 0.5rem;
      background-color: cornsilk;
      opacity: 0;
      text-align: center;
      border: 1px solid lightgray;
      border-radius: 5px;
      transition: opacity 0.2s;
      pointer-events: none;
      white-space: nowrap;
    }

    .list-el:hover .remove-hint {
      opacity: 1;
    }

    .models-list {
      border: 1px solid gray;
    }

    .models-list ul {
      color: skyblue;
    }

    .models-list ul li {
      color: yellow;
    }

    .model-name {
      color: #3e3e3e;
      background-color: #e3e3e3;
      margin-top: 3px;
      width: calc(100% -1rem);
      border-radius: 6px;
      padding-left: 1rem;
      cursor: pointer;
    }

    .fields-column {
      display: grid;
      grid-template-columns: 7rem 9.5rem;
      column-gap: 5px;
      width: max-content;
      padding: 6px 0 6px 1rem;
      height: auto;
      font-family: Georgia, 'Times New Roman', Times, serif;
      font-size: 15px !important;
      font-weight: 500 !important;
    }

    .fields-column p {
      margin: 4px 0 0 0;
      padding: 2px 0 0 4px 6pc;
      border-bottom: 1px solid lightgray;
      text-wrap: wrap;
    }

    .fields-column p:nth-child(odd) {
      color: skyblue;
      cursor: pointer;
      width: 100%;
      padding: 2px 0 2px 0.5rem;
    }

    .fields-column p:nth-child(even) {
      font-weight: 400 !important;
      font-size: 12px !important;
    }

    button {
      display: inline-block;
      margin: 1rem 1rem 1rem 0;
      background-color: navy;
      color: yellow;
      border: 1px solid gray;
      border-radius: 5px;
      font-size: 12px;
      cursor: pointer;
      padding: 3px 1rem;
      user-select: none;
    }

    .crud-support-done {
      width: max-content;
      padding: 5px 2rem;
      margin:1rem 0 0 0;
      color: lightgreen;
      font-size: 14px;
      border: 1px solid gray;
      border-radius:5px;
      cursor:pointer;
      text-align: center;
    }
    .hidden {
      display: none;
    }
    .dbname-block {
      display: grid;
      grid-template-columns: repeat(3, 12rem);
      column-gap: 0.2rem;
      margin: 0;
      padding: 0;

      label {
        width: 10rem;
        padding: 0;
        margin: 0 1rem 6px 0;
      }

      input {
        width: 11rem;
        margin: 0;
        padding: 3px 0 3px 0.5rem !important;
        border: 1px solid lightgray;
        border-radius: 3px;

        &:focus {
          outline: 1px solid skyblue;
        }
      }
    }
  </style>

</head>
<body>
<div>
  <h2 style='margin-left:8rem;'>Create CRUD Support</h2>

  <pre id='installPartOneId' class='hidden'>
      <h3>Prisma Installation Part One</h3>
The Extension 'Create CRUD Form Support' found that Prisma ORM is not installed 
in your project and it can help with installing it. In this the first part of the 
installation it will add all the necessary packages and instantiate Prisma in this 
project installing a very basic schema in /prisma/schema.prisma file at the project
root.

  <div class="dbname-block">
    <label for='dbNameId'>
      Database Name
      <br /><input id='dbNameId' type='text' placeholder='avoid dashes in name' />
    </label>
    <label for='dbOwnerId'>
      Database Owner
      <br /><input id='dbOwnerId' type='text' value="mili
"/>
    </label>
    <label for='dbOwnerPasswordId'>
      Owner's Password
      <br /><input id='dbOwnerPasswordId' type='password' />
    </label>
    <label for='dbHostId'>
      Host Name
      <br /><input id='dbHostId' type='string' value='localhost'/>
    </label>
    <label for='dbPortId'>
      Communication Port
      <br /><input id='dbPortId' type='number' value='5432'/>
    </label>
  </div>

  By specifying database name, database owner name and owner's password the Extension
will set the database connection string in the .env file and install with no interaptions, 
otherwise you should set it yourself and the process will ask for them latter on.
  It will open schema.prisma and .env contents in separate windows and a continue button 
waiting for you to 
  1)  Specify your Prisma models/tables replacing the current schema.prisma content.
  2)  Specify the connection string in the opened .env file if not set by the Extension.
When you are done select the continue button to finish the installation.
  If you would like to close the Extension in order to finish the above tasks you could
after that restart the Extension again and it will display the commands that you should
enter yourself or to select the continue button to allow the Extension to finish the 
installation

<button id='installPartOneBtnId'>Install Prisma ORM</button><button id='cancelPartOneBtnId'>Cancel</button>
  </pre>

  <pre id='installPartTwoId' class='hidden'>
          <h3>Prisma Installation Part Two</h3>
We assume that you finished below tasks
  1)  Ctrl + double-click on .env file to open it beside this Extension and
      enter valid connection string and save the file
  2)  Ctrl + double-click on /prisma/schema.prisma to open it beside the Extension
      and prepare schema models/tables
      Use model abilities for setting defaults, generating Ids,...
      Save the model.
Selecting the continue button the extension  will issue the final commands for installing 
Prisma, otherwise you can enter yourself the following commands

  sudo dropdb --if-exists -U "$DBOWNER" "$DBNAME" || true
  sudo -u postgres psql -c "DROP DATABASE IF EXISTS $DBNAME;"
  sudo -u postgres createdb "$DBNAME" -O "$DBOWNER"
  sudo -u postgres psql -d "$DBNAME" -c "GRANT ALL ON SCHEMA public TO $DBOWNER; GRANT CONNECT ON DATABASE $DBNAME TO $DBOWNER;"
  sudo -u postgres psql -d "$DBNAME" -c"GRANT ALL PRIVILEGES ON SCHEMA public TO $DBOWNER; ALTER SCHEMA public OWNER TO $DBOWNER; ALTER DATABASE dbtest OWNER TO $DBOWNER;"
  sudo -u postgres psql -d "$DBNAME" -c"ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO $DBOWNER; ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO $DBOWNER;"

  pnpx prisma migrate dev --name init		# create first migration (when ready)"
  pnpx prisma generate

  <button id='installPartTwoBtnId' style='margin-left:14rem;'>continue</button><button id='cancelPartTwoBtnId'>cancel</button>  
  </pre>

  <div id='crudUIBlockId' class='main-grid hidden'>
    <div class='grid-wrapper'>
      <pre class="span-two">
To create a UI Form for CRUD operations against the underlying ORM fill
out the <i>Candidate Fields</i> by entering field names in the <i>Field Name</i> input
box with its datatype, e.g. firstName: string,  and pressing the Enter key
or expand a table from the <i>Select Fields from ORM</i> block and click on
a field name avoiding the auto-generating fields usually colored in pink.
The UI Form +page.svelte with accompanying +page.server.ts will be 
created in the route specified in the Route Name input box.
      </pre>

      <div class='left-column'>
        <label for="routeNameId">Route Name
          <input id="routeNameId" type="text" />
        </label>
        <label for='fieldNameId'>Field Name
          <input id="fieldNameId" type="text" />
        </label>
        <button id="createBtnId" disabled>Create CRUD Support</button>
        <div class='crud-support-done hidden'></div>
        <div id='messagesId' style='z-index:10;width:20rem;'>Messages:</div>
      </div>

      <div class='middle-column'>
        <span class='candidate-fields-caption'>Candidate Fields</span>
        <div class="fields-list" id="fieldsListId"></div>
        <p id="removeHintId" class='remove-hint'>click to remove</p>
      </div>


      <div style='display:flex;height:1.4re !important;margin:0;padding:0;'>
        <input id="inputBoxWidthId" type="text" value='16rem' style='margin:0 1rem 0 0; padding:0 0 0 1rem;width:7rem;height:1.4rem !important;line-height:1.1rem;display:inline-block;' placeholder='CSS px, rem, ...'/>
        <label for="CRInput" style='display:inline-block;width:max-content'>All input boxes CSS width</label>
      </div>
      <div class="embellishments">
        <div class="checkbox-item">
          <input id="CRInput" type="checkbox" checked />
          <label for="CRInput">CRInput component</label>
        </div>
        <div class="checkbox-item">
          <input id="CRSpinner" type="checkbox" checked />
          <label for="CRSpinner">CRSpinner component</label>
        </div>
        <div class="checkbox-item">
          <input id="CRActivity" type="checkbox" checked />
          <label for="CRActivity">CRActivity component</label>
        </div>
        <div class="checkbox-item">
          <input id="CRTooltip" type="checkbox" checked />
          <label for="CRTooltip">Tooltip component</label>
        </div>
        <div class="checkbox-item">
          <input id="CRSummaryDetail" type="checkbox" checked />
          <label for="CRSummaryDetail">Summary/Details component</label>
        </div>
      </div>
    </div>
    <div id='rightColumnId' class='right-column hidden'>
      <span class='prisma-model-caption' onclick="closeSchemaModels()">Select Fields from ORM</span>
      <div id="schemaContainerId">
      </div>
    </div>
  </div>
</div>
</body>
<script>
  // Webview Extension
  let tablesModel = 'waiting for schemaModels '
  let rootPath = ''
  const vscode = acquireVsCodeApi()
  const noPrismaSchemaL = false ? true : false;
  const installPartTwoPending = false ? true : false;

  vscode.postMessage({ command: 'log', text: "noPrismaSchema:false; pending: false" })

  let noSchemaText = 'based on variable noPrismaSchema got from getWebviewContent ' + noPrismaSchemaL ? 'FOUND NO SCHEMA' : 'YES, SCHEMA FOUND'

  function installPartTwo() {
    vscode.postMessage({ command: 'installPrismaPartTwo' })
  }
  function cancelAnyPart() {
    fields = []
    closeSchemaModels()
    vscode.postMessage({ command: 'cancel' })
  }
  // all the elements needed to handle Prisma installation two parts
  // and the main CRUD support UI
  let installPartOneEl;
  let installPartTwoEl;
  let installPartOneBtnEl;
  let cancelPartOneBtnEl;
  let installPartTwoBtnEl;
  let cancelPartTwoBtnEl;
  let crudUIBlockEl;
  let rightColumnEl;
  let schemaContainerEl;
  let crudSupportDoneEl;
  let fieldModelsJSON;
  let fieldModels;
  let theFields = [];
  let msgEl;
  let labelEl;
  let routeName = '';
  let modelObjName = '';
  let routeLabelNode;
  let timer;
  let noRemoveHint = false;
  let inputBoxWidthEl;

  // Fires only one time
  // based on two variables noPrismaSchemaL and installPartTwoPending
  // prepare event listeners or if both are false make main page visible
  // This is how extension starts
  window.addEventListener('load', function () {
    // vscode.postMessage({ command: 'log', text: 'WINDOW LOAD EVENT CALLED' })

    crudUIBlockEl  = document.getElementById('crudUIBlockId')
    rightColumnEl = document.getElementById('rightColumnId')
    installPartOneEl = document.getElementById('installPartOneId')
    installPartTwoEl = document.getElementById('installPartTwoId')
    installPartOneBtnEl = document.getElementById('installPartOneBtnId')
    installPartTwoBtnEl = document.getElementById('installPartTwoBtnId')
    cancelPartOneBtnEl = document.getElementById('cancelPartOneBtnId')
    cancelPartTwoBtnEl = document.getElementById('cancelPartTwoBtnId')
    schemaContainerEl = document.getElementById('schemaContainerId')
    crudSupportDoneEl = document.querySelector('.crud-support-done')
    labelEl = document.querySelector("label[for='routeNameId']");
    inputBoxWidthEl = document.getElementById('inputBoxWidthId');
    routeLabelNode = Array.from(labelEl.childNodes).filter(
      (node) => node.nodeType === Node.TEXT_NODE
      )[0];
    msgEl = document.getElementById('messagesId')
    msgEl.addEventListener('dblclick', () => {
      msgEl.innerHTML = '<pre>'
    })


    if (noPrismaSchemaL){
      installPartOneBtnEl.addEventListener('click', () => {
      // vscode.postMessage({ command: 'log', text: 'InstallPartOneBtn clicked' })
        // get dbname, owner and owner password if specified
        try{
          const db = {};
          db.name = document.getElementById('dbNameId').value;
          db.owner = document.getElementById('dbOwnerId').value;
          db.password = document.getElementById('dbOwnerPasswordId').value;
          db.host = document.getElementById('dbHostId').value;
          db.port = document.getElementById('dbPortId').value;
          vscode.postMessage({ command: 'setDbAndOwner', payload: db });
        }catch(err){
          const msg = err instanceof Error ? err.message : String(err);
          vscode.postMessage({ command: 'log', text: 'get db err '+ msg })
        }
        vscode.postMessage({ command: 'installPrismaPartOne' })
        installPartOneBtnEl.innerText = 'installing...'
      })
      cancelPartOneBtnEl.addEventListener('click', cancelAnyPart)
      // fires once so be ready it extension waits for schema and connection
      installPartTwoBtnEl.addEventListener('click', installPartTwo)
      cancelPartTwoBtnEl.addEventListener('click', cancelAnyPart)
    }
    if (installPartTwoPending){
      vscode.postMessage({ command: 'log', text: 'pending!'})
      installPartTwoBtnEl.addEventListener('click', installPartTwo)
      cancelPartTwoBtnEl.addEventListener('click', cancelAnyPart)
    }
    // vscode.postMessage({ command: 'log', text: 'BEFORE TURNING PARTS VISIBLE' })

    if (noPrismaSchemaL) {
      vscode.postMessage({ command: 'log', text: '-- noPrismaSchemaL'})
      // all blocks start hidden
      installPartOneEl.classList.remove('hidden')
    }
    else if (installPartTwoPending){
      console.log('console.log -- installPartTwoPending')
      installPartTwoEl.classList.remove('hidden')
      // vscode.postMessage({ command: 'log', text: 'PRISMA PART TWO INSTALLATION' })
    }
    else {
      // console.log('console.log -- Create CRUD Support')
      // setTimeout(() => {
      crudUIBlockEl.classList.remove('hidden')
      rightColumnEl.classList.remove('hidden')
      vscode.postMessage({ command: 'readSchema' })
      // }, 0)
    }
  })


  function closeSchemaModels(){
    routeNameEl.value = '';
    fieldNameEl.value = '';
    setTimeout(() => {
      const children = schemaContainerEl.children
      for (child of children) {
        const det = child;
        if (det.hasAttribute('open')) {
          det.removeAttribute('open')
        }
      }
      fields = []
      fieldsListEl.innerHTML = '';
    },0)
  }

  function attachPartTwoButtons() {
    installPartTwoBtnEl.removeEventListener('click')
    installPartTwoBtnEl.addEventListener('click', () => {
        vscode.postMessage({ command: 'installPrismaPartTwo' })
      })
      cancelPartTwoBtnEl.addEventListener('click', () => {
        vscode.postMessage({ command: 'cancel' })
      })
  }

  let installPartOneDone = false;
  // Re-run binding when visible:
  window.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && installPartOneDone) {
      installPartTwoBtnEl.removeListener('click', installPartTwo);
      cancelPartTwoBtnEl.removeListener('click', cancelAnyPart);
      attachPartTwoButtons();
    }
  });

  // Listen for extension messages
  window.addEventListener("message", event => {

    const msg = event.data
    
    if (msg.command === 'ORMFieldsSent'){
      msgEl.innerHTML += "<p>target: " + msg.target +"</p>" + msg.markup;
    }

    if (msg.command === 'installPartOneDone'){
      installPartOneDone = true;
      installPartOneEl.classList.add('hidden');
      // event handlers are already established
      installPartTwoEl.classList.remove('hidden');
      // vscode.postMessage({command: 'log',  text: 'EXT: installPartOneDone' });
    }

    if (msg.command === 'installPartTwoDone'){
      // vscode.postMessage({ command: 'log',  text: 'EXT: installPartTwoDone' });
      installPartTwoEl.classList.add('hidden');
      crudUIBlockEl.classList.remove('hidden');
      rightColumnEl.classList.remove('hidden');
      // Request schema from the active extension
      vscode.postMessage({ command: 'readSchema' })
    }

    if (msg.command === 'createCrudSupportDone') {
      // vscode.postMessage({ command: 'log', text: 'EXT: createCrudSupportDone confirmed' })
      fieldsListEl.innerHTML = ''
      routeNameEl.value = ''
      crudSupportDoneEl.classList.remove('hidden')
      setTimeout(()=>{
        crudSupportDoneEl.classList.add('hidden');
      }, 3000)
      closeSchemaModels();
    }

    if (msg.command === 'renderSchema') {
      renderParsedSchema(msg.payload);
      rootPath = msg.rootPath;
      fieldModels= msg.modelsFieldNames;
    }

    if(msg.command === 'taskError'){
      vscode.postMessage({command: 'log',  text: 'EXT: Prisma installation err '+ msg.error});
    }

    if(msg.command === 'enableRemoveHint'){
      noRemoveHint = false
    }
  })

  // user clicks on fields list and it should click on a field name
  // rendered in skyblue
  function selectField(event) {
    const el = event.target
    const fieldName = el.innerText
    if (el.style.color === 'skyblue' && !fields.includes(fieldName)) {
      renderField(fieldName)
    }
  }

  // to send to an input box the Enter key up we need an event to dispatch
  const enterKeyEvent = new KeyboardEvent('keyup', {
    key: 'Enter',
    code: 'Enter',
    keyCode: 13,
    which: 13,
    bubbles: true
  })

  function dateTimeToDate(type) {
    if (type === 'DateTime') {
      return 'Date'
    }
    return type
  }

  function changeLabelText(color, text, duration){
    // Update the first (and likely only) text node
    const nodeText = routeLabelNode.textContent;
    // vscode.postMessage({command:'log', text: 'found textNode '+ nodeText})
    routeLabelNode.textContent = text;
    labelEl.style.color = color;
    timer = setTimeout(() => {
      routeLabelNode.textContent = nodeText;
      labelEl.style.color = '';
    }, duration)
  }

  function clearLabelText(){
    clearTimeout(timer);

    labelEl.style.color = '';
    routeLabelNode.textContent = 'Route Name';
  }

  // a parsed schema from a Prisma ORM is sent back from the extension
  // and as it is an HTML collection we turn it into an Object with
  // entries to be destructed into individual object properties
  function renderParsedSchema(schemaModels) {

    let markup = ''
    let types = ''
    let includeTypes = 'import type { '

    try {
      for (const [modelName, theFields] of Object.entries(schemaModels)) {

        types += `
  export type ${modelName} = {
    `
        includeTypes += modelName + ', '
        if (modelName === 'User') {
          includeTypes += 'Role, '
        }
        const [, fields] = Object.entries(theFields)[0]
        let m = ''


        for (const [fieldName, { type, prismaAttrs }] of Object.entries(fields)) {
          if ('0|1'.includes(fieldName)) continue
          types += `${fieldName}: ${dateTimeToDate(type)};
    `
          if (prismaAttrs.includes('@default') || prismaAttrs.includes('@updatedAt') || prismaAttrs.includes('@unique')) {
            m += `<p>${fieldName}</p><p>type:${type} <span style='color:pink'>${prismaAttrs ?? 'na'}</span></p>`
          } else {
            m += `<p>${fieldName}</p><p>type:${type} ${prismaAttrs ?? 'na'}</p>`
          }
        }


        types = types.slice(0, -3) +
          ` };
`
        // render field name as a collapsed summary to reveal field list when expanded
        markup += `<details>
          <summary class='model-name'>${modelName}</summary>
          <div class='fields-column'>${m}</div>
          </details>`
      }
      includeTypes = includeTypes.slice(0, -2) + ` }  from '$lib/types/types';
  `
      vscode.postMessage({ command: 'saveTypes', payload: {types, includeTypes} })
    } catch (err) {
      vscode.postMessage({command: 'log',  text: 'renderParsedSchema: ' + err });
    }
    // now all the markup constructed as a string render into  schemaContainerEl
    schemaContainerEl.innerHTML = markup

    // schemaContainerEl gets click event but it has to be from the first <p> element
    // and that fieldname (innerText) id ignored if already saved in the fields
    schemaContainerEl.addEventListener('click', (event) => {

      if (event.target.tagName === 'SUMMARY') {

        modelObjName = event.target.innerText;
        routeNameEl.value = modelObjName.toLowerCase();
        routeNameEl.focus()
        routeNameEl.click()
        const details = event.target.closest('details');
        if (details.open) {
          closeSchemaModels();
          clearLabelText();
          return;
        }
        changeLabelText('pink', 'Change Route Name if necessary', 4000)
        //----------------
        if (fieldModels){
          // msgEl.innerHTML += '<br/>SUMMARY fieldModels found: '+ JSON.stringify(fieldModels) + ' modelObjName: '+ modelObjName;

          vscode.postMessage({ command: 'log',  text: 'before calling Extension renderORMFields' });
          vscode.postMessage({ command: 'renderORMFields', target: 'just a string' })
          vscode.postMessage({ command: 'log',  text: 'after calling Extension renderORMFields' });

          try{
            theFields = fieldModels[modelObjName];
            msgEl.innerHTML += '<pre>'+ theFields + '</pre>';
            if (theFields){
              for (field of theFields){
                // msgEl.innerHTML += '<br/>theFields loop: '+ theFields[i];
                fieldNameEl.value = field;
                fieldNameEl.dispatchEvent(enterKeyEvent);
              }
              msgEl.innerHTML += '<pre>fields<br/>'+ JSON.stringify(fields,null,2) + '</pre>';
              return
            }
          }catch(err){
            const msg = err instanceof Error ? err.message : String(err);
            msgEl.innerHTML += '<br/>fieldModels[modelObjName] NOT found err: '+ msg
          }
        }else{
          msgEl.innerHTML += '<br/>SUMMARY fieldModels NOT found'
        }
      }

      // the click is not on a SUMMARY, so a field name is clicked
      // msgEl.innerHTML += '<br/>the click is not on a SUMMARY'
      const el = event.target
      const fieldName = el.innerText
      let type = dateTimeToDate(el.nextSibling.innerText.match(/type:(\S+)/)?.[1])
      if (!'String|Number|Boolean'.includes(type)) {
        return
      }

      // the standard procedure for entering a new fieldname is via input box + Enter
      if (el.tagName === 'P' && el.nextSibling.tagName === 'P' && !fields.includes(fieldName)) {
        // we need input box so preserve its entry if any and restore after
        const savedEntry = fieldNameEl.value
        fieldNameEl.value = `${fieldName}: ${type}`
        fieldNameEl.dispatchEvent(enterKeyEvent)
        fieldNameEl.value = savedEntry
      }
    })
  }

  // FieldsList elements use inline style for high specificity as they are created dynamically
  // by inserting innerHTML, so the inline style is in the listElCSS variable
  const listElCSS = 'color:black; font-size:14px; font-weight: 400; background-color: skyblue; margin: 2px 0 0 0;'

  // its data-filed-index are read via el.getAttribute('data-field-index')
  // or using camel case property name replacing 'data-' with .dataset
  // el.dataset.fieldIndex where data-field-index turn to .dataset.fieldIndex

  let fields = []
  // for removing element from the fields list every fieldName is given short id
  // as data-field-index HTML attribute and received on click event and read
  const getUniqueId = () => {
    // convert to a string of an integer from base 36
    return Math.random().toString(36).slice(2)
  }

  const removeHintEl = document.getElementById('removeHintId')
  removeHintEl.style.opacity = '0'    // make it as a hidden tooltip

  // when a fieldsList schemaContainerEl is full scroll it 
  // so the last element gets visible
  const scroll = (el) => {
    if (
      el.offsetHeight + el.scrollTop >
      el.getBoundingClientRect().height - 20
    ) {
      setTimeout(() => {
        el.scrollTo(0, el.scrollHeight)
      }, 0)
    }
  }
  // and the route name is specified
  const disableCreateButton = () => {
    createBtnEl.disabled = !fields.length || !routeName
  }

  function adjustFiledNameAndType(val) {
    val = val.replace(/\s+/g, '')

    if (!val.match(/\s*[a-zA-z0-9_]+\s*\:\s*([a-zA-z0-9_]+)/)?.[1]) {
      val = val.replace(/\:.*$/, '') + ': string'
    } else {
      val = val.replace(/([a-zA-z0-9_]+):([a-zA-z0-9_]+)/, '$1: $2')
    }
    return val
  }

  // the two input boxes for route name and fieldName, which are
  // used repeatedly for making Candidate Fields
  const routeNameEl = document.getElementById('routeNameId')
  const fieldNameEl = document.getElementById('fieldNameId')

  const fieldsListEl = document.getElementById('fieldsListId')
  const createBtnEl = document.getElementById('createBtnId')

  routeNameEl.addEventListener('input', (e) => {
    routeName = e.target.value
    disableCreateButton()
  })
  routeNameEl.addEventListener('click', (e) => {
    routeName = e.target.value
    disableCreateButton()
  })

  if (fieldNameEl) {
    fieldNameEl.addEventListener('keyup', (event) => {
      // vscode.postMessage({command: 'log',  text: 'fieldNameEl.addEventListener created' });
      let v = fieldNameEl.value.trim().replace(/\bstring\b/, 'String')
      if (!v) {
        // vscode.postMessage({command: 'log',  text: 'field is empty' });
        return
      }
      v = adjustFiledNameAndType(v)
      if (fields.includes(v)) {
        setTimeout(() => {
          fieldNameEl.style.color = 'red'
        }, 0)
        return
      }
      if (fieldNameEl.style.color === 'red') {
        fieldNameEl.style.color = 'black'
      }
      if (event.key !== 'Enter') return
      fields.push(v)
      disableCreateButton()
      renderField(v)
      fieldNameEl.value = ''
      scroll(fieldsListEl)
    })
  }
  // we do not clear all the entries and rebuild from the fields
  // but just add a newly entered in the Field Name fieldNameId
  function renderField(fieldName) {

    const fieldNameFromIndex = (index) => {
      const listEls = fieldsListEl.querySelectorAll('.list-el')
      let name = ''
      // forEach
      listEls.forEach(listEl => {
        if (listEl.dataset.fieldIndex === index) {
          name = listEl.firstChild.innerText
        }
      })
      return name
    }
    // Create elements
    const div = document.createElement('div')
    const span = document.createElement('span')

    // Set attributes and content
    div.className = 'list-el'
    div.dataset.fieldIndex = getUniqueId()
    div.style.setProperty('--hover-display', 'none')
    div.style.cssText = listElCSS

    span.className = 'field-text'
    span.textContent = fieldName

    // Append structure
    div.appendChild(span)
    fieldsListEl.appendChild(div)

    // so getBoundingClientRect() can be destructured
    // const { x, y } = fieldsListEl.getBoundingClientRect()
    setTimeout(() => {
      const listEls = fieldsListEl.querySelectorAll('.list-el')
      listEls.forEach(el => {
        el.addEventListener('mouseenter', () => {
          if (noRemoveHint) return
          removeHintEl.style.top = String(el.offsetTop - el.offsetHeight) + 'px'
          removeHintEl.style.left = String(el.offsetLeft + 12) + 'px'
          removeHintEl.style.opacity = '1'
        })

        el.addEventListener('mouseleave', () => {
          removeHintEl.style.opacity = '0'
        })

        el.addEventListener('click', () => {
          removeHintEl.style.opacity = '0'

          if (fieldNameEl.value === '') {
            fieldNameEl.value = el.innerText
            fieldNameEl.focus()
          }
          const index = el.dataset.fieldIndex
          const fieldName = fieldNameFromIndex(index)
          fields = fields.filter(el => el !== fieldName)
          el.remove()
        })
      })
    }, 400)
  }
  const selectedCheckboxes = () => {
    // Get all checkboxes in the document
    const checkboxes = document.querySelectorAll('input[type="checkbox"]')
    // Array of checked checkbox IDs only
    return Array.from(checkboxes)
      .filter(checkbox => checkbox.checked)
      .map(checkbox => checkbox.id)
  }

  createBtnEl.addEventListener('click', (event) => {
    noRemoveHint = true
    if (routeName && fields.length) {
      const inputBoxWidth = inputBoxWidthEl.value ?? '16rem';
      document.querySelector('.crud-support-done').innerHTML = "route <span style='color:pink;'>" + routeNameEl.value + "</span>  created";
      const payload = { routeName, modelObjName, fields, inputBoxWidth, embellishments: selectedCheckboxes() }
      vscode.postMessage({ command: 'createCrudSupport', payload: payload })
    }
  })
</script>
</body>

</html>
